
/*
    Вызывается после десериализации объектов из файла Interface Builder
    (also before life cycle UIViewController)
*/

 override func awakeFromNib() {
    super.awakeFromNib()
}

/*
    Загружает view в память
    Используется только без Storyboard!
    Бесполезен, если используются Storyboards.
*/

override func loadView() {
    //  В этом методе нужно создать кастомное View и инициализировать ее
    //  Задача метода загрузить это кастомное View в память
}


/*
    Вызывается когда view загрузилось в память
 */
override func viewDidLoad() {
    super.viewDidLoad() //  Нужно вызвать эту строку, чтобы были гарантии, что viewController будет функционировать корректно с базовым классом и его функциональностью
    
    //  Сначала необходимо вызвать метод у супер-класса
    //  Метод Super это обращение к родительскому классу и затем вызываем метод viewDidLoad()
}

/*
    После viewDidLoad происходит вызов метода viewWillAppear,
 
    В отличии от viewDidLoad(которое загружается в память один раз(а если два раза загружалось бы, то раннее он был выгружен из памяти),
    viewWillAppear загружается перед каждым появлением View
    
 */
override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
}


/*
        Это не метод жизненного цикла view!
        Но метод выполнится до того, как view отобразится на экране.
        Используется для того, чтобы обновить constraints после каких-либо действий.
        Очень редко используется, потому что constraints лучше обновлять после того, когда происходит обновление Layout.
        Layout - процесс расстановки элементов на экране, в соответствии с теми правилами, которые были заданы при помощи Contraints или Stack'ов.
        К примеру, если меняется ориентация смартфона, то необходимо Constraints менять в момент смены ориентации, НО это не этот метод для этого.
        Или если при нажатии на кнопку - меняются.
 
        Этот метод нужен для того, если обновить Constrains с задержкой. К примеру, нажали на кнопку и появляется анимация. И после завершения анимации
        необходимо обновить Constraints.
        Пока длится анимация, не меняются Constraints, только после завершения анимации - поменять Constraints.
        К примеру, после нажатия на кнопку элемент с одного угла экрана перемещается на другой. И пока длится процесс анимации - не надо менять Constraints.
        И только, когда элемент интерфейса достигает финальной точки, то необходимо обновить Constraints у этого элемента интерфейса.
        Если сделать в методе связанным с кнопкой, то constraints не обновятся из-за того, что код с обновлением constraints был раньше завершения анимации.
        
 */

override func updateViewConstraints() {
    // Здесь обновляем constraints
    
    
    //  Метод супер-класса вызывается в конце в отличии от предыдущих методов
    super.updateViewConstraints()
}
