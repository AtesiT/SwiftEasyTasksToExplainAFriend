
required init?(coder: NSCoder){
    super.init(coder: coder)
}

override init(){
    super.init()
}

/*
    Вызывается после десериализации объектов из файла Interface Builder
    (also before life cycle UIViewController)
*/

 override func awakeFromNib() {
    super.awakeFromNib()
}

/*
    Загружает view в память
    Используется только без Storyboard!
    Бесполезен, если используются Storyboards.
*/

override func loadView() {
    //  В этом методе нужно создать кастомное View и инициализировать ее
    //  Задача метода загрузить это кастомное View в память
}


/*
    Вызывается когда view загрузилось в память
 */
override func viewDidLoad() {
    super.viewDidLoad() //  Нужно вызвать эту строку, чтобы были гарантии, что viewController будет функционировать корректно с базовым классом и его функциональностью
    
    //  Сначала необходимо вызвать метод у супер-класса
    //  Метод Super это обращение к родительскому классу и затем вызываем метод viewDidLoad()
}

/*
    После viewDidLoad происходит вызов метода viewWillAppear,
 
    В отличии от viewDidLoad(которое загружается в память один раз(а если два раза загружалось бы, то раннее он был выгружен из памяти),
    viewWillAppear загружается перед каждым появлением View
    
 */
override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
}


/*
        Это не метод жизненного цикла view!
        Но метод выполнится до того, как view отобразится на экране.
        Используется для того, чтобы обновить constraints после каких-либо действий.
        Очень редко используется, потому что constraints лучше обновлять после того, когда происходит обновление Layout.
        Layout - процесс расстановки элементов на экране, в соответствии с теми правилами, которые были заданы при помощи Contraints или Stack'ов.
        К примеру, если меняется ориентация смартфона, то необходимо Constraints менять в момент смены ориентации, НО это не этот метод для этого.
        Или если при нажатии на кнопку - меняются.
 
        Этот метод нужен для того, если обновить Constrains с задержкой. К примеру, нажали на кнопку и появляется анимация. И после завершения анимации
        необходимо обновить Constraints.
        Пока длится анимация, не меняются Constraints, только после завершения анимации - поменять Constraints.
        К примеру, после нажатия на кнопку элемент с одного угла экрана перемещается на другой. И пока длится процесс анимации - не надо менять Constraints.
        И только, когда элемент интерфейса достигает финальной точки, то необходимо обновить Constraints у этого элемента интерфейса.
        Если сделать в методе связанным с кнопкой, то constraints не обновятся из-за того, что код с обновлением constraints был раньше завершения анимации.
        
 */

override func updateViewConstraints() {
    // Здесь обновляем constraints
    
    
    //  Метод супер-класса вызывается в конце в отличии от предыдущих методов
    super.updateViewConstraints()
}


/*
        Вызывается перед тем, как элементы интерфейса будут расставлены на экране (поэтому super.viewWill... - не обязательно)
        layout - расстановка элементов, subviews - дочерные элементы (сами элементы интерфейса, которые размещаются на view)
        Дословно: "View сейчас расставит свои элементы (subviews)
        У супер-класса нет своих элементов (поэтому и нет смысла вызывать super.viewWill... ), как правило. Но если вдруг есть (хотя не должно), то вызывать.
        
        В этом методе становится известно геометрические величины всех элементов интерфейса, включая View и Subview.
        Может вызываться несколько раз, перед тем как обновить layout.
        Обновляется, даже если просто поменять расположение бегунка (меняется layout).
 
        Может изначально два раза вызваться, если через print делать.
        В первый раз показывает значения Storyboard и во второй раз реальные значения.
*/

override func viewWillLayoutSubviews() {
    super.viewWillLayoutSubviews() //   Не требует вызова из супер-класса
    //  Здесь можем обращаться к элементам интерфейса, для которых значения должны быть динамические (зависеть от других элементов интерфейса)
    
    
}

/*
                                                    AUTO    LAYOUT
                                    Здесь происходит сам процесс расстановки интерфейса
                                    После завершения происходит вызов следующего метода
 
 */

/*
        Вызывается после того, как элементы интерфейса будут расставлены на экране.
        Используется для того, чтобы к примеру, зафиксировать расположение ячеек таблицы после их размещения.
        К примеру, чтобы сохранить расположения элементов, перейти на другой View, вернуться, а затем восстановить расположение элементов.
        Сохранить расположение ScrollView, TableView etc.
 
        Тоже вызывается дважды, как и viewWillLayoutSubviews, но по очереди (will, did, will, did). По той же причине.
        Тоже вызывается, при взаимодействии с элементами интерфейса.
 
 */

override func viewDidLayoutSubviews() {
    
}


/*
        После того как появляется View на экране пользователя, вызывается этот метод.
        Запускается чуть с задержкой, по сравнению с методами выше.
        Запускаются различные активности.
 */

override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)
}

/*
        Вызывается при изменении размеров экрана. К примеру, когда меняется ориентация экрана.
        size используется для возврата нового размера view, а coordinator используется для анимации при переходе из одного состояния в другое
        Он вызывается именно при изменении, а не при запуске приложения, к примеру.
 */

override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
    //  Также, здесь вызываются viewWillLayoutSubviews and viewDidLayoutSubviews
}

/*
        Метод срабатывает перед тем, как появится ВОЗМОЖНОСТЬ скрытия view (возможно скроется, но не факт)
        К примеру, перед тем как стоит начать постепенно свайпать экран назад (при ToolBar). После этого сразу сработают два метода(viewWillAppear, viewDidAppear)
        Или если перейти на экран другой, то сразу метод сработает.
 
        Говорит о том, что, если метод сработал, то мы останавливаем все активности, даже если еще экран не скрыт нами.
        Если присутствуют активности(видео, аниации) на экране, то они должны остановиться. И если передумает пользователь возвращаться назад, то
        активности надо запустить (методами viewWillAppear, viewDidAppear).
 */

override func viewWillDisappear(_ animated: Bool) {
    super.viewWillDisappear(animated)
}

/*
        Если всё-таки View скрылось, то вызывается данный метод.
        После того, как View скрылось - она выгружается из памяти (но не всегда, как если просто перейти по кнопке-segue).
        
        Здесь можно заниматься освобождением ресурсов, которые больше не нужны или останавливать сетевые активности, отменять операции запросов неактуальные.
        Но это можно и в viewWillDisappear.
 */

override func viewDidDisappear(_ animated: Bool) {
    super.viewDidDisappear(animated)
}

/*
        Оповещает о том, что объект был выгружен из памяти (от утечек памяти)
        Может вызываться для всех объектов, необязательно для View.
 */

deinit {
        
}


/*
        Если загрузить два View Controller и после загрузки находиться на первом ViewController. Переключиться с первого VC на второй VC.
        То, последовательность вызовов ViewControllers будет следующая.
        2-VC: viewDidLoad()                 -   Прежде, чем переходить с первого экрана на какой-либо, необходимо загрузить VC в память, на который будем переходить
        1-VC: viewWillDisapppear()          -   Начинаем подготовку к скрытию текущего ViewController (1-VC на низком старте скрытия VC)
        2-VC: viewWillAppear()              -   Начинаает подготавливать 2-VC к появлению
        2-VC: viewDidAppear()               -   Сообщает о том, что 2-VC появился
        1-VC: viewDidDisappear()            -   Сообщаем о том, что 1-VC скрылся
 */

/*
        Если закрывать VC, то последовательность будет та же, но кроме вызова viewDidLoad.
        Из особенностей, в конце будет вызван deinit, для того, чтобы константировать факт, что VC выгрузился из памяти.
        Также, номера VC будут другими. 
 */



